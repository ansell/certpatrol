### vim:syntax=js
###
### PREP SOURCE.. not in the mood for jaggler.. maybe i'll have to port later
### The following warning isn't for you if you can read this.
#// This file has been generated using prep.   http://perl.pages.de
###
### Currently no ifdefs in here.
##
## TODO: GeKo sagt: I mean you are not saving a cert but saying so at the moment...

/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * ''Certificate Patrol'' was conceived by Carlo v. Loesch and
 * implemented by Aiko Barz, Mukunda Modell, Carlo v. Loesch and Gabor Adam Toth.
 *
 * http://patrol.psyced.org
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *  
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete 
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *                              
 * ***** END LICENSE BLOCK ***** */
##
## The original Certificate Patrol code was slightly adapted by Georg Koppen, 
## JonDos GmbH 2010. The wildcard certificate functionality was developed by 
## Georg Koppen, JonDos GmbH 2010.

// This source code is formatted according to half-indented KNF.
var CertPatrol = {
    CHECK_ISSUER_ONLY: 1,
    locale: {},

    // Main
    onLoad: function() {
	this.initialized = true;
##	//this.strings = document.getElementById("CertPatrol-strings");
	this.dbinit();
	this.init();
    },

    // DB init
    dbinit: function() {
	this.dbh = null;
	this.db = {};

	try {
	    var file = Components.classes["@mozilla.org/file/directory_service;1"]
	      .getService(Components.interfaces.nsIProperties)
	      .get("ProfD", Components.interfaces.nsIFile);
	    var storage = Components.classes["@mozilla.org/storage/service;1"]
	      .getService(Components.interfaces.mozIStorageService);
	    file.append("CertPatrol.sqlite");

	    // Must be checked before openDatabase()
	    var exists = file.exists();

	    // Now, CertPatrol.sqlite exists
	    this.dbh = storage.openDatabase(file);

	    // CertPatrol.sqlite initialization
##	    // "GMT" is a historic lie here.. before version 1.3 we used to work
##	    // with notAfterGMT etc and try to parse the various renderings of it.
##	    // now it is too late and pointless to change the name in the sqlite
##	    // field. how i love SQL for its terrific flexibility...  ;)
##	    // why do most web apps still use this 1970s legacy interface?
	    if (!exists) {
		this.dbh.executeSimpleSQL("CREATE TABLE version (version INT)");
		this.dbh.executeSimpleSQL("INSERT INTO version (version) VALUES (3)");
		this.dbh.executeSimpleSQL(
		  "CREATE TABLE certificates ("+
		    "host VARCHAR, commonName VARCHAR, organization VARCHAR, organizationalUnit VARCHAR, "+
		    "serialNumber VARCHAR, emailAddress VARCHAR, notBeforeGMT VARCHAR, notAfterGMT VARCHAR, "+
		    "issuerCommonName VARCHAR, issuerOrganization VARCHAR, issuerOrganizationUnit VARCHAR, "+
		    "md5Fingerprint VARCHAR, sha1Fingerprint VARCHAR, "+
		    "issuerMd5Fingerprint VARCHAR, issuerSha1Fingerprint VARCHAR, "+
		    "cert BLOB, flags INT, stored INT)");
	    } else {
		var stmt = this.dbh.createStatement("SELECT version FROM version WHERE version < 2");
		try {
		    var old = stmt.executeStep();
		} catch (err) {
		    this.warn("Error trying to check SQL schema version: ", err);
		} finally {
		    stmt.reset();
		}
		if (old) {
		    this.dbh.executeSimpleSQL("ALTER TABLE certificates ADD COLUMN issuerMd5Fingerprint VARCHAR");
		    this.dbh.executeSimpleSQL("ALTER TABLE certificates ADD COLUMN issuerSha1Fingerprint VARCHAR");
		    this.dbh.executeSimpleSQL("ALTER TABLE certificates ADD COLUMN cert BLOB");
		    this.dbh.executeSimpleSQL("UPDATE version SET version = 2");
		}

		old = null;
		stmt = this.dbh.createStatement("SELECT version FROM version WHERE version < 3");
		try {
		    old = stmt.executeStep();
		} catch (err) {
		    this.warn("Error trying to check SQL schema version: ", err);
		} finally {
		    stmt.reset();
		}
		if (old) {
		    this.dbh.executeSimpleSQL("ALTER TABLE certificates ADD COLUMN flags INT");
		    this.dbh.executeSimpleSQL("ALTER TABLE certificates ADD COLUMN stored INT");
		    this.dbh.executeSimpleSQL("UPDATE version SET version = 3");
		}
	    }

	    // Prepared statements
	    this.db = {
		selectAll: this.dbh.createStatement("SELECT * FROM certificates"),
		selectHost: this.dbh.createStatement("SELECT * FROM certificates WHERE host=?1"),
		selectWild: this.dbh.createStatement("SELECT * FROM certificates WHERE md5Fingerprint=?12 AND sha1Fingerprint=?13"),
		insert: this.dbh.createStatement(
		  "INSERT INTO certificates ("+
		    "host, commonName, organization, organizationalUnit, serialNumber, emailAddress, "+
		    "notBeforeGMT, notAfterGMT, issuerCommonName, issuerOrganization, issuerOrganizationUnit, "+
		    "md5Fingerprint, sha1Fingerprint, issuerMd5Fingerprint, issuerSha1Fingerprint, cert, flags, stored) "+
		  "VALUES (?1,?2,?3,?4,?5,?6,?7,?8,?9,?10,?11,?12,?13,?14,?15,?16,?17,?18)"),
		update: this.dbh.createStatement(
		  "UPDATE certificates SET "+
		    "commonName=?2, organization=?3, organizationalUnit=?4, serialNumber=?5, emailAddress=?6, "+
		    "notBeforeGMT=?7, notAfterGMT=?8, issuerCommonName=?9, issuerOrganization=?10, issuerOrganizationUnit=?11, "+
		    "md5Fingerprint=?12, sha1Fingerprint=?13, issuerMd5Fingerprint=?14, issuerSha1Fingerprint=?15, cert=?16, flags=?17, stored=?18 "+
		  "WHERE host=?1"),
		delHost: this.dbh.createStatement("DELETE FROM certificates WHERE host=?1"),
		delSince: this.dbh.createStatement("DELETE FROM certificates WHERE stored >= ?18"),
		delAll: this.dbh.createStatement("DELETE FROM certificates"),
	    };
	} catch (err) {
	    this.warn("Error initializing SQLite operations: ", err);
	}
    },

    dbclose: function() {
	try {
	    if (this.dbh) {
		this.dbh.close();
		this.dbh = null;
	    }
	} catch (err) {
	    this.log("CertPatrol: Error trying to close connection: ", err);
	}
    },

    // Application trigger
    init: function() {
	var Cc = Components.classes, Ci = Components.interfaces;
	this.prefs = Cc["@mozilla.org/preferences-service;1"]
	  .getService(Ci.nsIPrefService)
	  .getBranch("certpatrol.")
	  .QueryInterface(Ci.nsIPrefBranch2);

	this.registerObserver("http-on-examine-response");
    },

    // helper functions for advanced patrol
    isodate: function(tim) {
	if (isNaN(tim)) {
##	    // this part of code can go when there are no more pre version 1.3
##	    // Certpatrol.sqlite instances around..
##	    //
##	    // i think i saw some cert dates without time info appended..
	    var iso = tim.replace(/^(\d\d)\/(\d\d)\/(\d+)/, "$3-$1-$2");
	    // upcoming Y3K bug, but you must delete this line before 2020
	    if (iso != tim) {
		if (iso[0] != '2') iso = "20"+ iso;
		return iso;
	    }
	}
	var d = new Date(tim / 1000);
##  // locale string is too verbose. we don't need weekdays and time zones here
##  // i was really afraid of having to do this. i love bad apis like Date().
##  return d.getFullYear() +"-"+
##	  (d.getMonth() < 10 ? "0"+ d.getMonth() : d.getMonth()) +"-"+
##	  (d.getDay() < 10 ? "0"+ d.getDay() : d.getDay()) +" "+
##	  (d.getHours() < 10 ? "0"+ d.getHours() : d.getHours()) +":"+
##	  (d.getMinutes() < 10 ? "0"+ d.getMinutes() : d.getMinutes());
##      // mozilla has this nice strftime extension to Date called toLocaleFormat()
	return d.toLocaleFormat("%Y-%m-%d %H:%M:%S");
##	// btw, this is not exactly ISO 8601 conformant but rather
##	// preserves its original intent.. universal readability (thus no 'T')
    },
    timedelta: function(tim) {
	if (!isNaN(tim)) tim /= 1000;
	var d = new Date(tim);
	// Y2K bug in Javascript...  :)
	if (d.getFullYear() < 2000) d.setFullYear(100 + d.getFullYear());
	var now = new Date();
	//alert("Now is "+ now.getTime() +" and cert is "+ d.getTime());
	return d.getTime() - now.getTime();
    },
    daysdelta: function(td) {
	td = Math.round(td / 86400000);	// milliseconds per day
	return " ("+ this.psycText(this.locale[td < 0 ? "daysPast" : "daysFuture"], {_days: td < 0 ? -td : td}) +")";
    },

    isodatedelta: function(tim) {
	return tim ? this.isodate(tim) + this.daysdelta(this.timedelta(tim)) : "";
    },

    byteArrayToString: function(ba) {
	var s = "";
	for (var i = 0; i < ba.length; i++)
            s += String.fromCharCode(ba[i]);
	return s;
    },

    byteArrayToCert: function(ba) {
	var Cc = Components.classes, Ci = Components.interfaces;
	var certdb = Cc["@mozilla.org/security/x509certdb;1"].getService(Ci.nsIX509CertDB);
	return certdb.constructX509FromBase64(window.btoa(this.byteArrayToString(ba.value)));
    },

    newCertObj: function() {
	return {
	    threat: 0,
	    flags: 0,
	    info: "",
	    host: "",
	    threatLevel: "",
	    warn: {},
	    moz: {
		  commonName: "",
		  organization: "",
		  organizationalUnit: "",
		  serialNumber: "",
		  emailAddress: "",
		  notBefore: "",
		  notAfter: "",
		  issuerCommonName: "",
		  issuerOrganization: "",
		  issuerOrganizationUnit: "",
		  md5Fingerprint: "",
		  sha1Fingerprint: "",
		  issuerMd5Fingerprint: "",
		  issuerSha1Fingerprint: "",
		  cert: null,
	    },
	    sql: {
		  commonName: "",
		  organization: "",
		  organizationalUnit: "",
		  serialNumber: "",
		  emailAddress: "",
		  notBefore: "",
		  notAfter: "",
		  issuerCommonName: "",
		  issuerOrganization: "",
		  issuerOrganizationUnit: "",
		  md5Fingerprint: "",
		  sha1Fingerprint: "",
		  issuerMd5Fingerprint: "",
		  issuerSha1Fingerprint: "",
		  cert: null,
	    },
	};
    },

    fillCertObj: function(obj, cert) {
	obj.cert = cert;
	obj.notBefore = cert.validity.notBefore;
	obj.notAfter = cert.validity.notAfter;
	if (cert.issuer) {
	    obj.issuerMd5Fingerprint = cert.issuer.md5Fingerprint;
	    obj.issuerSha1Fingerprint = cert.issuer.sha1Fingerprint;
	} else {
	    //this.log("no issuer: "+ [cert.commonName, cert.issuer, cert.sha1Fingerprint]);
	}

	var keys = ["commonName", "organization", "organizationalUnit", "serialNumber", "emailAddress",
		    "issuerCommonName", "issuerOrganization", "issuerOrganizationUnit",
		    "md5Fingerprint", "sha1Fingerprint"];
	for (var i in keys)
	    obj[keys[i]] = cert[keys[i]];
    },


    registerObserver: function(topic) {
	var observerService = Components.classes["@mozilla.org/observer-service;1"]
            .getService(Components.interfaces.nsIObserverService);
	observerService.addObserver(this, topic, false);
    },

    unregisterObserver: function(topic) {
	var observerService = Components.classes["@mozilla.org/observer-service;1"]
            .getService(Components.interfaces.nsIObserverService);
	observerService.removeObserver(this, topic);
    },

    observe: function(channel, topic, data) {
##	this.log(">> observe:", [channel, topic, data]);
	var Cc = Components.classes, Ci = Components.interfaces;

	channel.QueryInterface(Ci.nsIHttpChannel);
	var host = channel.URI.hostPort;
##	this.log("URI: "+ channel.URI.spec);

	var si = channel.securityInfo;
	if (!si)
	    return;

	var nc = channel.notificationCallbacks;
	if (!nc && channel.loadGroup)
	    nc = channel.loadGroup.notificationCallbacks;
	if (!nc)
	    return;

	try {
	    var win = nc.getInterface(Ci.nsIDOMWindow);
	} catch (e) {
	    return; // no window for e.g. favicons
	}

	if (!win.document)
	    return;

	var browser;
	if (typeof gBrowser != "undefined") // thunderbird has no gBrowser
	    browser = gBrowser.getBrowserForDocument(win.top.document);
##	//if (!browser) return; // no browser for e.g. favicons

	var wpl = Ci.nsIWebProgressListener;
	// proceed only if the page is considered secure or browser is null
	if (browser && !(browser.securityUI.state & wpl.STATE_IS_SECURE))
	    return;

	si.QueryInterface(Ci.nsISSLStatusProvider);
	var st = si.SSLStatus;
	if (!st) return;

	st.QueryInterface(Ci.nsISSLStatus);
	var cert = st.serverCert;
	if (!cert) return;

	var obj = browser || win.top;
	// store certs in the browser object so we can
	// show only one notification per host for a browser tab
	var key = [host, cert.md5Fingerprint, cert.sha1Fingerprint].join('|');
	if (obj.__certs && obj.__certs[key] && cert.equals(obj.__certs[key]))
	    return;
	obj.__certs = obj.__certs || {};
	obj.__certs[key] = cert;

	// The interesting part
	var certobj = this.newCertObj();
	certobj.host = host;
	certobj.ciphername = st.cipherName;
	certobj.keyLength = st.keyLength;
	certobj.secretKeyLength = st.secretKeyLength;
	this.fillCertObj(certobj.moz, cert);

	this.certCheck(browser, certobj);
    },

    // Certificate check
    certCheck: function(browser, certobj) {
##	this.log(">> certCheck: "+ certobj.host);
	var Cc = Components.classes, Ci = Components.interfaces;
	var found = false;

##	//if (this.last_sha1Fingerprint && this.last_sha1Fingerprint == certobj.moz.sha1Fingerprint) return;
##	//else this.last_sha1Fingerprint = certobj.moz.sha1Fingerprint;

	var pbs = Cc["@mozilla.org/privatebrowsing;1"];
	if (pbs) {
	    pbs = Cc["@mozilla.org/privatebrowsing;1"].getService(Ci.nsIPrivateBrowsingService);
	    var pbm = pbs.privateBrowsingEnabled;
	}
	var save = !pbm;
	try {
	    if (pbm && this.prefs)
		save = this.prefs.getBoolPref("privatebrowsing.save");
	} catch (err) {}

	// Get certificate
	var stmt = this.db.selectHost;
	try {
	    stmt.bindUTF8StringParameter(0, certobj.host);
	    if (stmt.executeStep()) {
		found = true;

		certobj.sql.commonName = stmt.getUTF8String(1);
		certobj.sql.organization = stmt.getUTF8String(2);
		certobj.sql.organizationalUnit = stmt.getUTF8String(3);
		certobj.sql.serialNumber = stmt.getUTF8String(4);
		certobj.sql.emailAddress = stmt.getUTF8String(5);
		certobj.sql.notBefore = stmt.getUTF8String(6);
		certobj.sql.notAfter = stmt.getUTF8String(7);
		certobj.sql.issuerCommonName = stmt.getUTF8String(8);
		certobj.sql.issuerOrganization = stmt.getUTF8String(9);
		certobj.sql.issuerOrganizationUnit = stmt.getUTF8String(10);
		certobj.sql.md5Fingerprint = stmt.getUTF8String(11);
		certobj.sql.sha1Fingerprint = stmt.getUTF8String(12);
		certobj.sql.issuerMd5Fingerprint = stmt.getUTF8String(13);
		certobj.sql.issuerSha1Fingerprint = stmt.getUTF8String(14);
		var blob = {};
		stmt.getBlob(15, {}, blob);
		if (blob.value.length)
		    certobj.sql.cert = this.byteArrayToCert(blob);
		certobj.flags = stmt.getInt64(16);
		certobj.sql.stored = stmt.getInt64(17) * 1000;
	    }
	} catch(err) {
	    this.warn("Error trying to check certificate: ", err);
	} finally {
	    stmt.reset();
	}

	var wild = this.wildcardCertCheck(certobj.moz.cert);

	// The certificate changed 
	if (found && (!certobj.sql.cert || !certobj.moz.cert.equals(certobj.sql.cert))) {
	    // If the cert info was stored in the previous version of CertPatrol
	    // we don't have the full cert yet, so we just store it in the DB
	    // and return if everything looks fine.
	    if (!certobj.sql.cert &&
		certobj.sql.sha1Fingerprint == certobj.moz.sha1Fingerprint &&
		certobj.sql.md5Fingerprint == certobj.moz.md5Fingerprint)
		    return this.saveCert(certobj);

	    // has the certificated hostname changed?
	    if (!wild && certobj.moz.commonName != certobj.sql.commonName) {
		certobj.warn.commonName = true;
		certobj.threat += 2;
	    }

	    if (!wild && !(certobj.flags & this.CHECK_ISSUER_ONLY)) {
		// try to make some sense out of the certificate changes
		var natd = this.timedelta(certobj.sql.notAfter);
		// certificate has expired
		if (natd <= 0) certobj.warn.notAfter_expired = true;
		// certificate still a long way to go
		else if (natd > 7777777777) {
##       	//else if (natd > 10364400000) {
		    certobj.threat ++;
		    certobj.warn.notAfter_notdue = true;
##		    // used to make it += 2 here, but in cases where server farms
##		    // use several valid certificates for the same host name that's
##		    // just too strict.
##		} else if (natd > 5182200000) {
##		    certobj.threat ++;
##		    certobj.warn.notAfter_due = true;
		}
		// certificate due sometime soonish
		else if (natd > 0) certobj.warn.notAfter_due = true;
	    }

	    // now looking into the NEW certificate
	    var td = this.timedelta(certobj.moz.notBefore);
	    if (td > 0) {
		// new certificate isn't valid yet
		certobj.warn.notBefore = true;
		certobj.threat += 2;
	    }
	    // further checks done by agent before we even get here

	    // check if they have the same issuer
##	    // VeriSign case suggests i should compare issuerOrganization instead...
	    if (certobj.sql.cert && certobj.moz.cert.issuer.equals(certobj.sql.cert.issuer)) {
		if (certobj.threat == 0 && certobj.flags & this.CHECK_ISSUER_ONLY)
		    return;
	    } else if (certobj.sql.cert ||
		       (!certobj.sql.cert && // old method, if we don't have a cert stored yet
			(certobj.moz.issuerOrganization != certobj.sql.issuerOrganization ||
			 certobj.moz.issuerCommonName != certobj.sql.issuerCommonName))) {
		certobj.warn.issuerCommonName = true;
		certobj.threat += 2;
	    }

	    // fetch suitable scare message
	    if (certobj.threat > 3) certobj.threat = 3;

	    // produce human readable expiration dates
	    certobj.sql.notBefore = this.isodatedelta(certobj.sql.notBefore);
	    certobj.sql.notAfter = this.isodatedelta(certobj.sql.notAfter);
	    certobj.moz.notBefore = this.isodatedelta(certobj.moz.notBefore);
	    certobj.moz.notAfter = this.isodatedelta(certobj.moz.notAfter);
	    //certobj.sql.stored = this.isodatedelta(certobj.sql.stored);

	    if (wild && certobj.threat == 0) {
		certobj.warn.wildcard = true;
		certobj.event = this.locale.wildEvent;
		this.outwild(browser, certobj);
		return;
	    }

	    certobj.event = this.locale.changeEvent +" "+
	        this.locale["threat"+ certobj.threat];
	    this.outchange(browser, certobj);

	    // New certificate
	} else if (!found) {
	    if (save) {
		// Store data
		stmt = this.db.insert;
		try {
		    stmt.bindUTF8StringParameter( 0, certobj.host);
		    stmt.bindUTF8StringParameter( 1, certobj.moz.commonName);
		    stmt.bindUTF8StringParameter( 2, certobj.moz.organization);
		    stmt.bindUTF8StringParameter( 3, certobj.moz.organizationalUnit);
		    stmt.bindUTF8StringParameter( 4, certobj.moz.serialNumber);
		    stmt.bindUTF8StringParameter( 5, certobj.moz.emailAddress);
		    stmt.bindUTF8StringParameter( 6, certobj.moz.notBefore);
		    stmt.bindUTF8StringParameter( 7, certobj.moz.notAfter);
		    stmt.bindUTF8StringParameter( 8, certobj.moz.issuerCommonName);
		    stmt.bindUTF8StringParameter( 9, certobj.moz.issuerOrganization);
		    stmt.bindUTF8StringParameter(10, certobj.moz.issuerOrganizationUnit);
		    stmt.bindUTF8StringParameter(11, certobj.moz.md5Fingerprint);
		    stmt.bindUTF8StringParameter(12, certobj.moz.sha1Fingerprint);
		    stmt.bindUTF8StringParameter(13, certobj.moz.issuerMd5Fingerprint);
		    stmt.bindUTF8StringParameter(14, certobj.moz.issuerSha1Fingerprint);
		    var der = certobj.moz.cert.getRawDER({});
		    stmt.bindBlobParameter(15, der, der.length);
		    stmt.bindInt64Parameter(16, 0);
		    stmt.bindInt64Parameter(17, parseInt(new Date().getTime() / 1000));
		    stmt.execute();
		} catch(err) {
		    this.warn("Error trying to insert certificate for "+
			      certobj.host +": ", err);
		} finally {
		    stmt.reset();
		}
	    }
##	    // checks are done by firefox before we even get here
##	    // that's why we don't complain about host != common name etc.
	    certobj.moz.notBefore = this.isodatedelta(certobj.moz.notBefore);
	    certobj.moz.notAfter = this.isodatedelta(certobj.moz.notAfter);

	    if (wild) {
		certobj.warn.wildcard = true;
		certobj.event = this.locale.wildEvent;
		this.outwild(browser, certobj);
		return;
	    }

	    certobj.event = this.locale.newEvent;
	    this.outnew(browser, certobj);
	}
    },

    // wildcardCertCheck contributed by Georg Koppen, JonDos GmbH 2010. Thanks!
    // We are using it differently, though. The JonDos version is less paranoid.
    //
    wildcardCertCheck: function(cert) {
	var stmt;

	// First, we check whether we have a wildcard certificate at all. If not
	// just return false and the new cert dialog will be schown. But even if
	// we have one but no SHA1 fingerprint we should show it for security's
	// sake...
##  alert("doing wildcardCertCheck for "+ sha1Fingerprint);
	if (cert.commonName.charAt(0) === '*' && cert.md5Fingerprint && cert.sha1Fingerprint) {
	    // We got one, check now if we have it already. If not, return false and
	    // the certificate will be shown. Otherwise, return yes and the new cert
	    // dialog will be omitted.
	    try {
		stmt = this.db.selectWild;
		// starts counting from 0, so ?13 is 12 here. you gotta love it.
		stmt.bindUTF8StringParameter(11, cert.md5Fingerprint);
		stmt.bindUTF8StringParameter(12, cert.sha1Fingerprint);
		if (stmt.executeStep()) {
		    return true;
		} else {
		    // This case could occur as well if we have *.example.com and
		    // foo.example.com with SHA1(1) saved and we find a cert with
		    // *.example.com and bar.example.com and SHA1(2): We would show
		    // the dialog even if we have already saved the wildcard cert. But
		    // that's okay due to the changed SHA1 fingerprint, thus prioritizing
		    // security and not convenience...
		    return false;
		}
	    } catch (err) {
		this.warn("Error trying to check wildcard certificate "+
			  cert.commonName +": ", err);
	    } finally {
		stmt.reset();
	    }
	} else {
	    return false;
	}
    },

    // accept changed cert
    saveCert: function(certobj) {
##	this.log(">> saveCert: "+ certobj.host);
	var stmt = this.db.update;
	var cert = certobj.moz.cert;
	try {
	    stmt.bindUTF8StringParameter( 0, certobj.host);
	    stmt.bindUTF8StringParameter( 1, cert.commonName);
	    stmt.bindUTF8StringParameter( 2, cert.organization);
	    stmt.bindUTF8StringParameter( 3, cert.organizationalUnit);
	    stmt.bindUTF8StringParameter( 4, cert.serialNumber);
	    stmt.bindUTF8StringParameter( 5, cert.emailAddress);
	    stmt.bindUTF8StringParameter( 6, cert.validity.notBefore);
	    stmt.bindUTF8StringParameter( 7, cert.validity.notAfter);
	    stmt.bindUTF8StringParameter( 8, cert.issuerCommonName);
	    stmt.bindUTF8StringParameter( 9, cert.issuerOrganization);
	    stmt.bindUTF8StringParameter(10, cert.issuerOrganizationUnit);
	    stmt.bindUTF8StringParameter(11, cert.md5Fingerprint);
	    stmt.bindUTF8StringParameter(12, cert.sha1Fingerprint);
	    stmt.bindUTF8StringParameter(13, cert.issuer.md5Fingerprint);
	    stmt.bindUTF8StringParameter(14, cert.issuer.sha1Fingerprint);
	    var der = cert.getRawDER({});
	    stmt.bindBlobParameter(15, der, der.length);
	    stmt.bindInt64Parameter(16, certobj.flags);
	    stmt.bindInt64Parameter(17, parseInt(new Date().getTime() / 1000));
	    stmt.execute();
	} catch(err) {
	    this.warn("Error trying to update certificate: ", err);
	} finally {
	    stmt.reset();
	}
	return true;
    },

    // reject new cert
    delCert: function(host) {
	var stmt;
	try {
	    stmt = this.db.delHost;
	    stmt.bindUTF8StringParameter(0, host);
	    stmt.executeStep();
	} catch (err) {
	    this.warn("Error while trying to remove certificate: ", err);
	} finally {
	    stmt.reset();
	}
    },

    delCerts: function(hosts) {
	if (!hosts || !hosts.length)
	    return;
	if (!this.dbh)
	    this.dbinit();

	var params = [];
	for (var i=1; i<=hosts.length; i++)
	    params.push('?'+i);

	try {
	    var stmt = this.dbh.createStatement("DELETE FROM certificates WHERE host IN ("+ params.join(",") +")");
	    for (var i=0; i<hosts.length; i++)
		stmt.bindUTF8StringParameter(i, hosts[i]);
	    stmt.executeStep();
	} catch (err) {
	    this.warn("Error while trying to remove certificates: ", err);
	} finally {
	    stmt.reset();
	}
    },

    // sanitizer - clear recent history
    delCertsSince: function(range) {
	if (!this.dbh)
	    this.dbinit();
	var stmt;
	try {
	    if (range) {
		stmt = this.db.delSince;
		stmt.bindInt64Parameter(17, range[0] / 1000000);
	    } else {
		stmt = this.db.delAll;
	    }
	    stmt.executeStep();
	} catch (err) {
	    this.warn("Error while trying to remove certificates: ", err);
	} finally {
	    stmt.reset();
	}
    },

    updateFlags: function(hosts, flag, on) {
	if (!hosts || !hosts.length)
	    return;
	if (typeof hosts != 'object')
	    hosts = [hosts];
	if (!this.dbh)
	    this.dbinit();

	var params = [];
	for (var i=0; i<hosts.length; i++)
	    params.push('?'+ (i+2));

	try {
	    var stmt;
	    if (on)
		stmt = this.dbh.createStatement("UPDATE certificates SET flags = flags | ?1 WHERE host IN ("+ params.join(",") +")");
	    else
		stmt = this.dbh.createStatement("UPDATE certificates SET flags = flags & ~?1 WHERE host IN ("+ params.join(",") +")");
	    stmt.bindInt64Parameter(0, flag);
	    for (var i=0; i<hosts.length; i++)
		stmt.bindUTF8StringParameter(i+1, hosts[i]);
	    stmt.executeStep();
	} catch (err) {
	    this.warn("Error while trying to update flags: ", err);
	} finally {
	    stmt.reset();
	}

	try {
	    stmt = this.dbh.createStatement("UPDATE certificates SET flags = ?1 WHERE flags IS NULL AND host IN ("+ params.join(",") +")");
	    stmt.bindInt64Parameter(0, flag);
	    for (var i=0; i<hosts.length; i++)
		stmt.bindUTF8StringParameter(i+1, hosts[i]);
	    stmt.executeStep();
	} catch (err) {
	    this.warn("Error while trying to update flags: ", err);
	} finally {
	    stmt.reset();
	}
    },

    setFlag: function(certobj, flag, on) {
	if (on)
	    certobj.flags |= flag;
	else
	    certobj.flags &= ~flag;
    },

    getAllCerts: function() {
	if (!this.dbh)
	    this.dbinit();
	var certs = [];
	var stmt;
	try {
	    stmt = this.db.selectAll;
	    while (stmt.executeStep()) {
		var obj = {
		    host: stmt.getUTF8String(0),
		    commonName: stmt.getUTF8String(1),
		    organization: stmt.getUTF8String(2),
		    organizationalUnit: stmt.getUTF8String(3),
		    serialNumber: stmt.getUTF8String(4),
		    emailAddress: stmt.getUTF8String(5),
		    md5Fingerprint: stmt.getUTF8String(11),
		    sha1Fingerprint: stmt.getUTF8String(12),
		    validity: {
			notBefore: stmt.getUTF8String(6),
			notAfter: stmt.getUTF8String(7),
		    },
		    issuer: {
			commonName: stmt.getUTF8String(8),
			organization: stmt.getUTF8String(9),
			organizationUnit: stmt.getUTF8String(10),
			issuerMd5Fingerprint: stmt.getUTF8String(13),
			issuerSha1Fingerprint: stmt.getUTF8String(14),
		    },
		    flags: stmt.getInt64(16),
		    stored: stmt.getInt64(17) * 1000,
		};
		var blob = {};
		stmt.getBlob(15, {}, blob);
		if (blob.value.length) {
		    var cert = this.byteArrayToCert(blob);
		    if (cert)
			this.fillCertObj(obj, cert);
		}
		certs.push(obj);
	    }
	} catch (err) {
	    this.warn("Error while trying to get certificates: ", err);
	} finally {
	    stmt.reset();
	}
	return certs;
    },

    outnew: function(browser, certobj) {
	var forcePopup = false;
	try {
	    if (this.prefs) forcePopup = this.prefs.getBoolPref("popup.new");
	} catch (err) {}

	var notifyBox = this.getNotificationBox(browser);
	var popup = forcePopup || !notifyBox;
##      // https://developer.mozilla.org/en/XUL/Method/appendNotification
##      // http://gist.github.com/256554
##      // using certobj.host as the id for the notification
	if (notifyBox && !popup) {
	    notifyBox.appendNotification(
		"(CertPatrol) "+ certobj.event +" "+
		    certobj.moz.commonName +". "+
		    this.locale.issuedBy +" "+
		    (certobj.moz.issuerOrganization || certobj.moz.issuerCommonName),
		certobj.host, null, notifyBox.PRIORITY_INFO_HIGH,
		[{
		    label: this.locale.reject,
		    accessKey: this.locale.reject_key,
		    callback: function(msg, btn) {
			CertPatrol.delCert(certobj.host);
		    }
		}, {
		    label: this.locale.viewDetails,
		    accessKey: this.locale.viewDetails_key,
		    callback: function(msg, btn) {
			window.openDialog("chrome://certpatrol/content/new.xul",
					  "_blank", "chrome,dialog,modal",
					  certobj, CertPatrol);
		    }
		}]);
	}
	if (popup)
	    window.openDialog("chrome://certpatrol/content/new.xul", "_blank",
			      "chrome,dialog,modal", certobj, CertPatrol);
    },

    outwild: function(browser, certobj) {
	var forcePopup = false;
	try {
	    if (this.prefs) forcePopup = this.prefs.getBoolPref("popup.wild");
	} catch (err) {}

	var notifyBox = this.getNotificationBox(browser);
	var popup = forcePopup || !notifyBox;
	if (notifyBox && !popup) {
	    notifyBox.appendNotification(
		"(CertPatrol) "+ certobj.event +" "+
		    certobj.moz.commonName +". "+
		    this.locale.issuedBy +" "+
		    (certobj.moz.issuerOrganization || certobj.moz.issuerCommonName),
		certobj.host, null, notifyBox.PRIORITY_INFO_HIGH,
		[{
		    label: this.locale.reject,
		    accessKey: this.locale.reject_key,
		    callback: function(msg, btn) {
			CertPatrol.delCert(certobj.host);
		    }
		}, {
		    label: this.locale.viewDetails,
		    accessKey: this.locale.viewDetails_key,
		    callback: function(msg, btn) {
			window.openDialog("chrome://certpatrol/content/new.xul",
					  "_blank", "chrome,dialog,modal",
					  certobj, CertPatrol);
		    }
		}]);
	}
	if (popup)
	    window.openDialog("chrome://certpatrol/content/change.xul",
			      "_blank", "chrome,dialog,modal", certobj, CertPatrol);
    },

    outchange: function(browser, certobj) {
	var forcePopup = false;
	try {
	    if (this.prefs) forcePopup = this.prefs.getBoolPref("popup.change");
	} catch (err) {}

	var notifyBox = this.getNotificationBox(browser);
	var popup = forcePopup || certobj.threat > 1 || !notifyBox;
	if (notifyBox && !popup) {
	    var priority = [
		notifyBox.PRIORITY_INFO_LOW,
		notifyBox.PRIORITY_INFO_HIGH,
		notifyBox.PRIORITY_WARNING_HIGH,
		notifyBox.PRIORITY_CRITICAL_HIGH
	    ];
	    notifyBox.appendNotification(
		"(CertPatrol) "+ certobj.event +" "+
		    certobj.moz.commonName +". "+
		    this.locale.issuedBy +" "+
		    (certobj.moz.issuerOrganization || certobj.moz.issuerCommonName)
		    +" "+ certobj.info,
		certobj.host, null, priority[certobj.threat],
		[{
		    label: this.locale.accept,
		    accessKey: this.locale.accept_key,
		    callback: function(msg, btn) {
			CertPatrol.saveCert(certobj);
		    }
		}, {
		    label: this.locale.viewDetails,
		    accessKey: this.locale.viewDetails_key,
		    callback: function(msg, btn) {
			window.openDialog("chrome://certpatrol/content/change.xul",
					  "_blank", "chrome,dialog,modal",
					  certobj, CertPatrol);
		    }
		}]);
	}
	if (popup)
	    window.openDialog("chrome://certpatrol/content/change.xul", "_blank",
			      "chrome,dialog,modal", certobj, CertPatrol);
    },

    getNotificationBox: function (win) {
	if (typeof gBrowser != "undefined")
	    return gBrowser.getNotificationBox(win);

	if (window.getNotificationBox)
	    return window.getNotificationBox(); // does not seem to work
    },

    warn: function(result, error) {
	if (error) result += error +" at "+ error.fileName +" line "+ error.lineNumber;
	window.openDialog("chrome://certpatrol/content/warning.xul",
			  "_blank", "chrome,dialog,modal", result);
	this.log("CertPatol: "+ result);
    },

    log: function(s, a) {
	if (a && a.length && a.join)
	    s += " " + a.join(", ");
	Components.classes["@mozilla.org/consoleservice;1"].getService(Components.interfaces.nsIConsoleService).logStringMessage(s);
    },

    // functions for the new & change dialogs

    addCertChain: function(node, cert) {
	if (!cert)
	    return;
	var chain = cert.getChain();
	var text = "";
	for (var i = chain.length - 1; i >= 0; i--) {
            var cert = chain.queryElementAt(i, Components.interfaces.nsIX509Cert);
	    text += Array((chain.length - i - 1) * 2 + 1).join(" ") + "- " + (cert.commonName || cert.windowTitle) + (i > 0 ? "\n" : "");
	}
	node.value = text;
	node.clickSelectsAll = true;
	node.setAttribute("rows", chain.length);
    },

    viewCert: function(cert, parent) {
	Components.classes["@mozilla.org/nsCertificateDialogs;1"]
            .getService(Components.interfaces.nsICertificateDialogs)
	    .viewCert(parent, cert);
    },

    psycText: function(template, vars) {
	return template.replace(/\[(\w+)\]/g, function(match, name) {
            return name in vars ? vars[name] : match;
	});
    }
};
